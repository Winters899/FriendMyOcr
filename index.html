<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OCR RU/EN ‚Üí DOCX</title>
  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 1100px;
      margin: 20px auto;
      padding: 0 12px;
      line-height: 1.3;
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .col {
      display: grid;
      gap: 10px;
    }
    .box {
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 12px;
    }
    .muted {
      color: #555;
    }
    .hint {
      font-size: 13px;
      color: #666;
    }
    canvas {
      border: 1px solid #ddd;
      border-radius: 10px;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
    textarea {
      width: 100%;
      min-height: 180px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    button {
      padding: 10px 14px;
      cursor: pointer;
    }
    label {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }
    .split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 900px) {
      .split {
        grid-template-columns: 1fr;
      }
    }
    .badge {
      display: inline-block;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f1f3f5;
      border: 1px solid #e9ecef;
      color: #495057;
    }
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 9999;
    }
    .modal.open {
      display: block;
    }
    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,.35);
    }
    .modal-card {
      position: relative;
      max-width: 820px;
      margin: 6vh auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.2);
    }
    pre.cmd {
      white-space: pre-wrap;
      word-break: break-word;
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 10px;
      padding: 10px;
      margin: 8px 0;
    }
  </style>

  <!-- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∑–∞–≥—Ä—É–∑—á–∏–∫ —Å–∫—Ä–∏–ø—Ç–æ–≤ —Å fallback -->
  <script>
    function loadScriptWithFallback(urls) {
      let i = 0;
      function loadNext() {
        if (i >= urls.length) return;
        const s = document.createElement('script');
        s.src = urls[i++];
        s.onerror = loadNext;
        document.head.appendChild(s);
      }
      loadNext();
    }

    // Tesseract.js
    loadScriptWithFallback([
      'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js',
      'https://unpkg.com/tesseract.js@5/dist/tesseract.min.js'
    ]);

    // docx
    loadScriptWithFallback([
      'https://cdn.jsdelivr.net/npm/docx@9.5.1/dist/index.iife.js',
      'https://unpkg.com/docx@9.5.1/dist/index.iife.js'
    ]);

    // FileSaver
    loadScriptWithFallback([
      'https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js',
      'https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js'
    ]);

    // OpenCV.js
    window.opencvloadfailed = false;
    window.Module = window.Module || {};
    window.Module.locateFile = path => 'https://docs.opencv.org/4.x/' + path;
  </script>
  <script src="https://docs.opencv.org/4.x/opencv.js"
          onerror="window.opencvloadfailed=true"></script>
</head>

<body>
  <h1>OCR RU/EN ‚Üí DOCX</h1>

  <div class="box col">
    <div class="row">
      <input id="file" type="file" accept="image/*" />
      <label>–†–µ–∂–∏–º
        <select id="mode">
          <option value="digits">–¶–∏—Ñ—Ä—ã</option>
          <option value="text" selected>–¢–µ–∫—Å—Ç (RU/EN)</option>
        </select>
      </label>
      <label id="langWrap">
        –Ø–∑—ã–∫
        <select id="lang">
          <option value="rus">–†—É—Å—Å–∫–∏–π (rus)</option>
          <option value="eng">English (eng)</option>
          <option value="rus+eng" selected>–†—É—Å—Å–∫–∏–π + English (rus+eng)</option>
        </select>
      </label>
      <label>PSM
        <select id="psm">
          <option value="6">6 (–±–ª–æ–∫ —Ç–µ–∫—Å—Ç–∞)</option>
          <option value="7">7 (–æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞)</option>
          <option value="8" selected>8 (–æ–¥–Ω–æ —Å–ª–æ–≤–æ/—á–∏—Å–ª–æ)</option>
          <option value="10">10 (–æ–¥–∏–Ω —Å–∏–º–≤–æ–ª)</option>
        </select>
      </label>
      <label>–£–≤–µ–ª–∏—á–µ–Ω–∏–µ
        <select id="scale">
          <option value="1">x1</option>
          <option value="2" selected>x2</option>
          <option value="3">x3</option>
        </select>
      </label>
      <label>–ò–Ω–≤–µ—Ä—Å–∏—è
        <select id="invert">
          <option value="0" selected>–ù–µ—Ç</option>
          <option value="1">–î–∞ (–±–µ–ª–æ–µ –Ω–∞ —á—ë—Ä–Ω–æ–º)</option>
        </select>
      </label>
      <label>–ü–æ—Ä–æ–≥
        <select id="thresh">
          <option value="otsu" selected>Otsu</option>
          <option value="adaptive">Adaptive</option>
          <option value="none">–ë–µ–∑ –ø–æ—Ä–æ–≥–∞</option>
        </select>
      </label>
      <button id="run" disabled>–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å</button>
      <button id="download" disabled>–°–∫–∞—á–∞—Ç—å DOCX</button>
      <button id="openServerBtn" type="button">–û—Ç–∫—Ä—ã—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä</button>
      <span id="cvBadge" class="badge">OpenCV: –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ</span>
    </div>
    <div class="hint">
      –í—ã–¥–µ–ª–∏ –æ–±–ª–∞—Å—Ç—å —Å —Ç–µ–∫—Å—Ç–æ–º/—Ü–∏—Ñ—Ä–∞–º–∏ –Ω–∞ –ª–µ–≤–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ (ROI) ‚Äî —Ç–∞–∫ —Ç–æ—á–Ω–æ—Å—Ç—å –æ–±—ã—á–Ω–æ –≤—ã—à–µ.
      –ï—Å–ª–∏ OpenCV –Ω–µ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è, OCR –≤—Å—ë —Ä–∞–≤–Ω–æ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç (–±–µ–∑ –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∏ OpenCV).
    </div>
  </div>

  <div id="status" class="muted">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è‚Ä¶</div>

  <div class="split" style="margin-top: 14px;">
    <div class="box col">
      <div class="row">
        <div>üì∑</div>
        <div class="muted">–û—Ä–∏–≥–∏–Ω–∞–ª</div>
      </div>
      <canvas id="srcCanvas" width="800" height="600"></canvas>
    </div>
    <div class="box col">
      <div class="row">
        <div>üé®</div>
        <div class="muted">–ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞</div>
      </div>
      <canvas id="prepCanvas" width="800" height="600"></canvas>
    </div>
  </div>

  <div class="box col" style="margin-top: 14px;">
    <div class="row">
      <div>üìÑ</div>
      <div><b>–†–µ–∑—É–ª—å—Ç–∞—Ç OCR</b></div>
    </div>
    <textarea id="out" placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..."></textarea>
  </div>

  <div id="digitsWrap" class="col" style="display: grid;">
    <div class="row">
      <div class="muted">–¶–∏—Ñ—Ä—ã + –∑–Ω–∞–∫–∏ (—Ñ–∏–ª—å—Ç—Ä: 0‚Äì9 . , -):</div>
    </div>
    <textarea id="digits" placeholder="0-9 . , -"></textarea>
  </div>

  <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ –ª–æ–∫–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É -->
  <div id="serverModal" class="modal" aria-hidden="true">
    <div class="modal-backdrop"></div>
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="serverModalTitle">
      <div class="row" style="justify-content: space-between; align-items: center;">
        <div id="serverModalTitle"><b>–õ–æ–∫–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä</b></div>
        <button id="closeServerModal" type="button">–ó–∞–∫—Ä—ã—Ç—å</button>
      </div>
      <div class="muted" style="margin-top: 8px;">
        –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Ç–∫—Ä—ã–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ http://localhost (–∞ –Ω–µ file://), —á—Ç–æ–±—ã OpenCV/Tesseract –≥—Ä—É–∑–∏–ª–∏—Å—å —Å—Ç–∞–±–∏–ª—å–Ω–µ–µ.
      </div>

      <div style="margin-top:10px;">
        <div class="badge">1. Python</div>
        <pre id="cmdPython" class="cmd">python3 -m http.server 8000</pre>
        <div class="row">
          <button type="button" data-copy="#cmdPython">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
          <a href="http://localhost:8000/ocr.html" target="_blank" rel="noopener">
            –û—Ç–∫—Ä—ã—Ç—å http://localhost:8000/ocr.html
          </a>
        </div>
      </div>

      <div style="margin-top:10px;">
        <div class="badge">2. Python (—Ç–æ–ª—å–∫–æ –ª–æ–∫–∞–ª—å–Ω–æ)</div>
        <pre id="cmdPythonBind" class="cmd">python3 -m http.server 8000 --bind 127.0.0.1</pre>
        <div class="row">
          <button type="button" data-copy="#cmdPythonBind">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <div class="badge">3. Node (–µ—Å–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω)</div>
        <pre id="cmdNode" class="cmd">npx serve .</pre>
        <div class="row">
          <button type="button" data-copy="#cmdNode">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è: –æ—Ç–∫—Ä–æ–π —Ç–µ—Ä–º–∏–Ω–∞–ª –≤ –ø–∞–ø–∫–µ —Å ocr.html ‚Üí –≤—Å—Ç–∞–≤—å –∫–æ–º–∞–Ω–¥—É ‚Üí Enter ‚Üí –æ—Ç–∫—Ä–æ–π —Å—Å—ã–ª–∫—É –Ω–∞ localhost.
      </div>
    </div>
  </div>

  <script>
    // –≠–ª–µ–º–µ–Ω—Ç—ã
    const fileEl = document.getElementById('file');
    const modeEl = document.getElementById('mode');
    const langWrap = document.getElementById('langWrap');
    const langEl = document.getElementById('lang');
    const psmEl = document.getElementById('psm');
    const scaleEl = document.getElementById('scale');
    const invertEl = document.getElementById('invert');
    const threshEl = document.getElementById('thresh');
    const runBtn = document.getElementById('run');
    const dlBtn = document.getElementById('download');
    const statusEl = document.getElementById('status');
    const cvBadgeEl = document.getElementById('cvBadge');
    const outEl = document.getElementById('out');
    const digitsWrap = document.getElementById('digitsWrap');
    const digitsEl = document.getElementById('digits');
    const srcCanvas = document.getElementById('srcCanvas');
    const prepCanvas = document.getElementById('prepCanvas');
    const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });

    const openServerBtn = document.getElementById('openServerBtn');
    const serverModal = document.getElementById('serverModal');
    const closeServerModal = document.getElementById('closeServerModal');

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    let imageBitmap = null;
    let roi = { x: 0, y: 0, w: 0, h: 0 };
    let dragging = false;
    let dragStart = null;
    let cvReady = false;
    let ocrWorker = null;
    let workerLangKey = null;
    let workerBusy = false;

    function setStatus(msg) { statusEl.textContent = msg; }

    function refreshUiByMode() {
      const mode = modeEl.value;
      langWrap.style.display = mode === 'text' ? 'inline-flex' : 'none';
      digitsWrap.style.display = mode === 'text' ? 'grid' : 'none';
    }
    modeEl.addEventListener('change', refreshUiByMode);

    function clampRoiToCanvas() {
      roi.x = Math.max(0, Math.min(roi.x, srcCanvas.width - 1));
      roi.y = Math.max(0, Math.min(roi.y, srcCanvas.height - 1));
      roi.w = Math.max(1, Math.min(roi.w, srcCanvas.width - roi.x));
      roi.h = Math.max(1, Math.min(roi.h, srcCanvas.height - roi.y));
    }

    function setDefaultRoi() {
      if (!imageBitmap) return;
      roi = {
        x: Math.round(imageBitmap.width * 0.1),
        y: Math.round(imageBitmap.height * 0.2),
        w: Math.round(imageBitmap.width * 0.8),
        h: Math.round(imageBitmap.height * 0.6)
      };
      clampRoiToCanvas();
    }

    function drawSourceWithRoi() {
      if (!imageBitmap) return;
      srcCanvas.width = imageBitmap.width;
      srcCanvas.height = imageBitmap.height;
      srcCtx.clearRect(0, 0, srcCanvas.width, srcCanvas.height);
      srcCtx.drawImage(imageBitmap, 0, 0);
      clampRoiToCanvas();
      srcCtx.save();
      srcCtx.strokeStyle = 'rgba(0,140,255,0.95)';
      srcCtx.lineWidth = Math.max(2, Math.round(Math.min(srcCanvas.width, srcCanvas.height) / 300));
      srcCtx.setLineDash([6, 4]);
      srcCtx.strokeRect(roi.x + 0.5, roi.y + 0.5, roi.w, roi.h);
      srcCtx.restore();
    }

    function canvasPointFromEvent(e) {
      const r = srcCanvas.getBoundingClientRect();
      const scaleX = srcCanvas.width / r.width;
      const scaleY = srcCanvas.height / r.height;
      return {
        x: Math.round((e.clientX - r.left) * scaleX),
        y: Math.round((e.clientY - r.top) * scaleY)
      };
    }

    // ROI –º—ã—à—å—é
    srcCanvas.addEventListener('pointerdown', e => {
      if (!imageBitmap) return;
      dragging = true;
      srcCanvas.setPointerCapture(e.pointerId);
      const p = canvasPointFromEvent(e);
      dragStart = p;
      roi = { x: p.x, y: p.y, w: 1, h: 1 };
      drawSourceWithRoi();
    });

    srcCanvas.addEventListener('pointermove', e => {
      if (!dragging || !imageBitmap) return;
      const p = canvasPointFromEvent(e);
      const x1 = Math.min(dragStart.x, p.x);
      const y1 = Math.min(dragStart.y, p.y);
      const x2 = Math.max(dragStart.x, p.x);
      const y2 = Math.max(dragStart.y, p.y);
      roi = { x: x1, y: y1, w: Math.max(1, x2 - x1), h: Math.max(1, y2 - y1) };
      drawSourceWithRoi();
    });

    srcCanvas.addEventListener('pointerup', async () => {
      if (!dragging) return;
      dragging = false;
      drawSourceWithRoi();
      try { await preprocessToCanvas(); } catch (err) {}
    });

    async function loadImageFromFile(file) {
      imageBitmap = await createImageBitmap(file);
      setDefaultRoi();
      drawSourceWithRoi();
      prepCanvas.width = imageBitmap.width;
      prepCanvas.height = imageBitmap.height;
    }

    function parseLangForWorker(langStr) {
      const parts = langStr.split('+').map(s => s.trim()).filter(Boolean);
      return parts.length === 1 ? parts[0] : parts;
    }

    function updateCvBadge() {
      cvBadgeEl.textContent = cvReady ? 'OpenCV: –≥–æ—Ç–æ–≤' : 'OpenCV: fallback';
    }

    function waitForOpenCvReady(timeoutMs = 15000) {
      return new Promise((resolve, reject) => {
        const t0 = Date.now();
        const check = () => {
          if (window.opencvloadfailed) {
            cvReady = false;
            updateCvBadge();
            return reject(new Error('OpenCV.js –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è'));
          }
          if (window.cv && typeof cv.Mat === 'function') {
            cvReady = true;
            updateCvBadge();
            return resolve(true);
          }
          if (Date.now() - t0 > timeoutMs) {
            cvReady = false;
            updateCvBadge();
            return reject(new Error('OpenCV.js —Ç–∞–π–º–∞—É—Ç'));
          }
          setTimeout(check, 80);
        };
        check();
      });
    }

    async function preprocessFallbackToCanvas() {
      if (!imageBitmap) throw new Error('–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
      clampRoiToCanvas();
      const scale = parseInt(scaleEl.value, 10) || 1;
      prepCanvas.width = Math.max(1, roi.w * scale);
      prepCanvas.height = Math.max(1, roi.h * scale);
      const ctx = prepCanvas.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = true;
      ctx.clearRect(0, 0, prepCanvas.width, prepCanvas.height);
      ctx.drawImage(imageBitmap, roi.x, roi.y, roi.w, roi.h, 0, 0, prepCanvas.width, prepCanvas.height);

      if (invertEl.value === '1') {
        const img = ctx.getImageData(0, 0, prepCanvas.width, prepCanvas.height);
        const d = img.data;
        for (let i = 0; i < d.length; i += 4) {
          d[i] = 255 - d[i];
          d[i + 1] = 255 - d[i + 1];
          d[i + 2] = 255 - d[i + 2];
        }
        ctx.putImageData(img, 0, 0);
      }

      const blob = await new Promise(res => prepCanvas.toBlob(res, 'image/png'));
      return blob;
    }

    async function preprocessToCanvas() {
      if (!imageBitmap) throw new Error('–ù–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è');
      if (!cvReady || !window.cv || typeof cv.Mat !== 'function') {
        return await preprocessFallbackToCanvas();
      }

      clampRoiToCanvas();
      const roiCanvas = document.createElement('canvas');
      roiCanvas.width = roi.w;
      roiCanvas.height = roi.h;
      const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });
      roiCtx.drawImage(imageBitmap, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

      const src = cv.imread(roiCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      const scale = parseInt(scaleEl.value, 10) || 1;
      let resized = gray;
      if (scale !== 1) {
        resized = new cv.Mat();
        const dsize = new cv.Size(gray.cols * scale, gray.rows * scale);
        cv.resize(gray, resized, dsize, 0, 0, cv.INTER_CUBIC);
      }
      gray.delete();

      const threshMode = threshEl.value;
      let out = resized;

      if (threshMode === 'otsu') {
        const bin = new cv.Mat();
        const invert = invertEl.value === '1';
        const t = invert ? (cv.THRESH_BINARY_INV | cv.THRESH_OTSU) : (cv.THRESH_BINARY | cv.THRESH_OTSU);
        cv.threshold(resized, bin, 0, 255, t);
        if (out !== resized) out.delete();
        out = bin;
      } else if (threshMode === 'adaptive') {
        const bin = new cv.Mat();
        const invert = invertEl.value === '1';
        const adaptiveType = cv.ADAPTIVE_THRESH_GAUSSIAN_C;
        const threshType = invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY;
        cv.adaptiveThreshold(resized, bin, 255, adaptiveType, threshType, 31, 7);
        if (out !== resized) out.delete();
        out = bin;
      } else if (invertEl.value === '1') {
        const inv = new cv.Mat();
        cv.bitwise_not(resized, inv);
        if (out !== resized) out.delete();
        out = inv;
      }

      prepCanvas.width = out.cols;
      prepCanvas.height = out.rows;
      cv.imshow(prepCanvas, out);

      src.delete();
      if (resized !== out) resized.delete();
      out.delete();

      const blob = await new Promise(res => prepCanvas.toBlob(res, 'image/png'));
      return blob;
    }

    function tesseractConfigCDN() {
      return {
        workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js',
        corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5.1.0',
        langPath: 'https://tessdata.projectnaptha.com/4.0.0',
        errorHandler: err => {
          try { setStatus(`OCR worker error: ${err?.message || err}`); }
          catch (e) { console.error(err); }
        },
        logger: m => {
          if (m.status) {
            if (typeof m.progress === 'number') {
              setStatus(`OCR ${m.status} ${(m.progress * 100).toFixed(0)}%`);
            } else {
              setStatus(`OCR ${m.status}`);
            }
          }
        }
      };
    }

    async function ensureWorker(langKey, workerLang) {
      if (ocrWorker && workerLangKey === langKey) return ocrWorker;

      if (ocrWorker) {
        try { await ocrWorker.terminate(); } catch (e) {}
        ocrWorker = null;
        workerLangKey = null;
      }

      if (!window.Tesseract) {
        throw new Error('Tesseract.js –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª—Å—è. –ü—Ä–æ–≤–µ—Ä—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç/CDN.');
      }

      ocrWorker = await Tesseract.createWorker(workerLang, 1, tesseractConfigCDN());
      workerLangKey = langKey;
      return ocrWorker;
    }

    async function recognize(prepBlob) {
      const mode = modeEl.value;
      const psm = String(psmEl.value);
      const langStr = mode === 'text' ? langEl.value : 'eng';
      const workerLang = parseLangForWorker(langStr);
      const langKey = mode === 'text' ? langStr : 'eng+digits';

      const worker = await ensureWorker(langKey, workerLang);
      const params = { tessedit_pageseg_mode: psm };
      if (mode === 'digits') params.tessedit_char_whitelist = '0123456789.,-';
      await worker.setParameters(params);

      const ret = await worker.recognize(prepBlob);
      return ret?.data?.text ?? '';
    }

    function makeDocxAndDownload(mode, lang, psm, text, digitsOnly) {
      if (!window.docx) throw new Error('–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ docx –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∞—Å—å');
      if (!window.saveAs) throw new Error('FileSaver –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω');

      const { Document, Paragraph, Packer } = window.docx;
      const meta = [
        'OCR',
        mode,
        mode === 'text' ? lang : '',
        `PSM ${psm}`,
        `Scale x${scaleEl.value}`,
        `Invert: ${invertEl.value === '1' ? 'yes' : 'no'}`,
        `Threshold: ${threshEl.value}`
      ].filter(Boolean);

      const paras = meta.map(s => new Paragraph({ text: s }));
      paras.push(new Paragraph({ text: '--- OCR ---' }));
      text.split(/\r?\n/).forEach(line => paras.push(new Paragraph({ text: line })));
      paras.push(new Paragraph({ text: '---' }));
      paras.push(new Paragraph({ text: '--- –¶–ò–§–†–´ ---' }));
      paras.push(new Paragraph({ text: digitsOnly }));

      const doc = new Document({ sections: [{ children: paras }] });
      Packer.toBlob(doc).then(blob => saveAs(blob, 'ocr.docx'));
    }

    // –ú–æ–¥–∞–ª–∫–∞
    function openModal() {
      serverModal.classList.add('open');
      serverModal.setAttribute('aria-hidden', 'false');
    }
    function closeModal() {
      serverModal.classList.remove('open');
      serverModal.setAttribute('aria-hidden', 'true');
    }
    openServerBtn.addEventListener('click', openModal);
    closeServerModal.addEventListener('click', closeModal);
    serverModal.querySelector('.modal-backdrop').addEventListener('click', closeModal);
    window.addEventListener('keydown', e => { if (e.key === 'Escape') closeModal(); });
    serverModal.addEventListener('click', async e => {
      const btn = e.target.closest('[data-copy]');
      if (!btn) return;
      const pre = serverModal.querySelector(btn.getAttribute('data-copy'));
      const text = pre?.textContent.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        setStatus('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
      } catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        ta.remove();
        setStatus('–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ (fallback)');
      }
    });

    // –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞
    fileEl.addEventListener('change', async () => {
      const file = fileEl.files?.[0];
      if (!file) return;
      outEl.value = '';
      digitsEl.value = '';
      dlBtn.disabled = true;
      runBtn.disabled = true;
      setStatus('–ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è...');
      try {
        await loadImageFromFile(file);
        await preprocessToCanvas();
        setStatus('–ì–æ—Ç–æ–≤–æ. –í—ã–¥–µ–ª–∏ ROI –∏ –Ω–∞–∂–º–∏ "–†–∞—Å–ø–æ–∑–Ω–∞—Ç—å"');
      } catch (e) {
        setStatus(e?.message || '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏');
      }
      runBtn.disabled = false;
    });

    // –ó–∞–ø—É—Å–∫ OCR
    runBtn.addEventListener('click', async () => {
      if (!imageBitmap || workerBusy) return;
      workerBusy = true;
      runBtn.disabled = true;
      dlBtn.disabled = true;
      outEl.value = '';
      digitsEl.value = '';

      try {
        setStatus('–ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞...');
        const prepBlob = await preprocessToCanvas();
        setStatus('OCR...');
        const text = await recognize(prepBlob);
        const cleanedText = text.trim();
        outEl.value = cleanedText;
        const digitsOnly = text.replace(/[^0-9.,-]/g, '');
        digitsEl.value = digitsOnly;

        if (cleanedText.length) {
          dlBtn.disabled = false;
          setStatus(`–ì–æ—Ç–æ–≤–æ. DOCX –¥–æ—Å—Ç—É–ø–µ–Ω (${cleanedText.length} —Å–∏–º–≤–æ–ª–æ–≤)`);
        } else {
          setStatus('–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π PSM/ROI/–ø–æ—Ä–æ–≥');
        }
      } catch (e) {
        setStatus(e?.message || '–û—à–∏–±–∫–∞ OCR');
        console.error(e);
      } finally {
        workerBusy = false;
        runBtn.disabled = false;
      }
    });

    // –°–∫–∞—á–∞—Ç—å DOCX
    dlBtn.addEventListener('click', () => {
      try {
        makeDocxAndDownload(modeEl.value, langEl.value, psmEl.value, outEl.value, digitsEl.value);
      } catch (e) {
        setStatus(e?.message || '–û—à–∏–±–∫–∞ DOCX');
        console.error(e);
      }
    });

    // Init
    async function init() {
      refreshUiByMode();
      updateCvBadge();
      setStatus('OpenCV.js –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...');
      try {
        await waitForOpenCvReady(15000);
        setStatus('OpenCV.js –≥–æ—Ç–æ–≤');
      } catch (e) {
        setStatus(`${e.message}. OCR —Ä–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ OpenCV.`);
      }
      if (location.protocol === 'file:') {
        openModal();
        runBtn.disabled = true;
      }
    }
    init();

    window.addEventListener('beforeunload', async () => {
      if (ocrWorker) {
        try { await ocrWorker.terminate(); } catch (e) {}
      }
    });
  </script>
</body>
</html>
