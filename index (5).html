<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OCR RU/EN → DOCX</title>

  <style>
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width: 1100px;
      margin: 20px auto;
      padding: 0 12px;
      line-height: 1.3;
    }
    .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    .col{ display:grid; gap:10px; }
    .box{ padding:12px; border:1px solid #ddd; border-radius:12px; }
    .muted{ color:#555; }
    .hint{ font-size:13px; color:#666; }
    canvas{
      border:1px solid #ddd;
      border-radius:10px;
      max-width:100%;
      height:auto;
      touch-action: none;
    }
    textarea{
      width:100%;
      min-height:180px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    button{ padding:10px 14px; cursor:pointer; }
    label{ display:inline-flex; gap:8px; align-items:center; }
    .split{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
    @media (max-width: 900px){
      .split{ grid-template-columns:1fr; }
    }
    .badge{
      display:inline-block;
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      background:#f1f3f5;
      border:1px solid #e9ecef;
      color:#495057;
    }

    /* modal */
    .modal{ display:none; position:fixed; inset:0; z-index:9999; }
    .modal.open{ display:block; }
    .modal__backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.35); }
    .modal__card{
      position:relative;
      max-width: 820px;
      margin: 6vh auto;
      background:#fff;
      border:1px solid #ddd;
      border-radius:12px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.2);
    }
    pre.cmd{
      white-space: pre-wrap;
      word-break: break-word;
      background:#f8f9fa;
      border:1px solid #e9ecef;
      border-radius:10px;
      padding:10px;
      margin:8px 0;
    }
  </style>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- docx -->
  <script src="https://cdn.jsdelivr.net/npm/docx@9.5.1/build/index.umd.js"></script>
  <!-- FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <!-- OpenCV.js (может не загрузиться — есть fallback) -->
  <script>
    // Если opencv.js попытается догрузить wasm — подскажем базовый URL
    window.Module = window.Module || {};
    window.Module.locateFile = (path) => "https://docs.opencv.org/4.x/" + path;

    window.__opencv_load_failed = false;
  </script>
  <script
    src="https://docs.opencv.org/4.x/opencv.js"
    onerror="window.__opencv_load_failed=true;"
  ></script>
</head>

<body>
  <h1>OCR RU/EN → DOCX</h1>

  <div class="box col">
    <div class="row">
      <input id="file" type="file" accept="image/*" />

      <label>
        Режим
        <select id="mode">
          <option value="digits">Цифры</option>
          <option value="text" selected>Текст (RU/EN)</option>
        </select>
      </label>

      <label id="langWrap" style="display:inline-flex;">
        Язык
        <select id="lang">
          <option value="rus">Русский (rus)</option>
          <option value="eng">English (eng)</option>
          <option value="rus+eng" selected>Русский + English (rus+eng)</option>
        </select>
      </label>

      <label>
        PSM
        <select id="psm">
          <option value="6">6 (блок текста)</option>
          <option value="7">7 (одна строка)</option>
          <option value="8" selected>8 (одно слово/число)</option>
          <option value="10">10 (один символ)</option>
        </select>
      </label>

      <label>
        Увеличение
        <select id="scale">
          <option value="1">x1</option>
          <option value="2" selected>x2</option>
          <option value="3">x3</option>
        </select>
      </label>

      <label>
        Инверсия
        <select id="invert">
          <option value="0" selected>Нет</option>
          <option value="1">Да (белое на чёрном)</option>
        </select>
      </label>

      <label>
        Порог
        <select id="thresh">
          <option value="otsu" selected>Otsu</option>
          <option value="adaptive">Adaptive</option>
          <option value="none">Без порога</option>
        </select>
      </label>

      <button id="run" disabled>Распознать</button>
      <button id="download" disabled>Скачать DOCX</button>
      <button id="openServerBtn" type="button">Открыть локальный сервер</button>

      <span id="cvBadge" class="badge">OpenCV: неизвестно</span>
    </div>

    <div class="hint">
      Выдели область с текстом/цифрами на левом изображении (ROI) — так точность обычно выше.
      Если OpenCV не загрузится, OCR всё равно сработает (без предобработки OpenCV).
    </div>

    <div id="status" class="muted">Инициализация…</div>
  </div>

  <div class="split" style="margin-top:14px;">
    <div class="box col">
      <div class="row">
        <div><b>Оригинал</b></div>
        <div class="muted">(выдели ROI)</div>
      </div>
      <canvas id="srcCanvas"></canvas>
    </div>

    <div class="box col">
      <div class="row">
        <div><b>Предобработка</b></div>
        <div class="muted">(для OCR)</div>
      </div>
      <canvas id="prepCanvas"></canvas>
    </div>
  </div>

  <div class="box col" style="margin-top:14px;">
    <div class="row"><div><b>Результат OCR</b></div></div>
    <textarea id="out" placeholder="Тут появится распознанный текст…"></textarea>

    <div id="digitsWrap" class="col" style="display:grid;">
      <div class="row"><div class="muted">Цифры + знаки (фильтр: 0–9 . , -):</div></div>
      <textarea id="digits" placeholder="Тут появятся только цифры и знаки (.,-)…"></textarea>
    </div>
  </div>

  <!-- Modal: Local server instructions -->
  <div id="serverModal" class="modal" aria-hidden="true">
    <div class="modal__backdrop"></div>
    <div class="modal__card" role="dialog" aria-modal="true" aria-labelledby="serverModalTitle">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div id="serverModalTitle"><b>Локальный сервер</b></div>
        <button id="closeServerModal" type="button">Закрыть</button>
      </div>

      <div class="muted" style="margin-top:8px;">
        Рекомендуется открывать страницу по http://localhost (а не file://), чтобы OpenCV/Tesseract грузились стабильнее.
      </div>

      <div style="margin-top:10px;">
        <div class="badge">Вариант 1: Python</div>
        <pre id="cmdPython" class="cmd">python3 -m http.server 8000</pre>
        <div class="row">
          <button type="button" data-copy="#cmdPython">Скопировать</button>
          <a href="http://localhost:8000/ocr.html" target="_blank" rel="noopener">Открыть http://localhost:8000/ocr.html</a>
        </div>
      </div>

      <div style="margin-top:10px;">
        <div class="badge">Вариант 2: Python (только локально)</div>
        <pre id="cmdPythonBind" class="cmd">python3 -m http.server 8000 --bind 127.0.0.1</pre>
        <div class="row">
          <button type="button" data-copy="#cmdPythonBind">Скопировать</button>
        </div>
      </div>

      <div style="margin-top:10px;">
        <div class="badge">Вариант 3: Node (если установлен)</div>
        <pre id="cmdNode" class="cmd">npx serve .</pre>
        <div class="row">
          <button type="button" data-copy="#cmdNode">Скопировать</button>
        </div>
      </div>

      <div class="hint" style="margin-top:10px;">
        Как пользоваться: открой терминал в папке с ocr.html → вставь команду → Enter → открой ссылку на localhost.
      </div>
    </div>
  </div>

<script>
  const fileEl = document.getElementById('file');
  const modeEl = document.getElementById('mode');
  const langWrap = document.getElementById('langWrap');
  const langEl = document.getElementById('lang');
  const psmEl = document.getElementById('psm');
  const scaleEl = document.getElementById('scale');
  const invertEl = document.getElementById('invert');
  const threshEl = document.getElementById('thresh');
  const runBtn = document.getElementById('run');
  const dlBtn = document.getElementById('download');
  const statusEl = document.getElementById('status');
  const cvBadgeEl = document.getElementById('cvBadge');

  const outEl = document.getElementById('out');
  const digitsWrap = document.getElementById('digitsWrap');
  const digitsEl = document.getElementById('digits');

  const srcCanvas = document.getElementById('srcCanvas');
  const prepCanvas = document.getElementById('prepCanvas');
  const srcCtx = srcCanvas.getContext('2d', { willReadFrequently: true });

  // modal elements
  const openServerBtn = document.getElementById('openServerBtn');
  const serverModal = document.getElementById('serverModal');
  const closeServerModal = document.getElementById('closeServerModal');

  let imageBitmap = null;

  // ROI
  let roi = { x: 0, y: 0, w: 0, h: 0 };
  let dragging = false;
  let dragStart = null;

  // OpenCV status
  let cvReady = false;

  // Tesseract worker cache
  let ocrWorker = null;
  let workerLangKey = null;
  let workerBusy = false;

  function setStatus(msg){ statusEl.textContent = msg; }

  function refreshUiByMode(){
    const mode = modeEl.value;
    langWrap.style.display = (mode === 'text') ? 'inline-flex' : 'none';
    digitsWrap.style.display = 'grid';
  }

  modeEl.addEventListener('change', refreshUiByMode);

  function clampRoiToCanvas(){
    roi.x = Math.max(0, Math.min(roi.x, srcCanvas.width - 1));
    roi.y = Math.max(0, Math.min(roi.y, srcCanvas.height - 1));
    roi.w = Math.max(1, Math.min(roi.w, srcCanvas.width - roi.x));
    roi.h = Math.max(1, Math.min(roi.h, srcCanvas.height - roi.y));
  }

  function setDefaultRoi(){
    if (!imageBitmap) return;
    roi = {
      x: Math.round(imageBitmap.width * 0.10),
      y: Math.round(imageBitmap.height * 0.20),
      w: Math.round(imageBitmap.width * 0.80),
      h: Math.round(imageBitmap.height * 0.60)
    };
    clampRoiToCanvas();
  }

  function drawSourceWithRoi(){
    if (!imageBitmap) return;

    srcCanvas.width = imageBitmap.width;
    srcCanvas.height = imageBitmap.height;

    srcCtx.clearRect(0, 0, srcCanvas.width, srcCanvas.height);
    srcCtx.drawImage(imageBitmap, 0, 0);

    clampRoiToCanvas();
    srcCtx.save();
    srcCtx.strokeStyle = 'rgba(0, 140, 255, 0.95)';
    srcCtx.lineWidth = Math.max(2, Math.round(Math.min(srcCanvas.width, srcCanvas.height) / 300));
    srcCtx.setLineDash([6, 4]);
    srcCtx.strokeRect(roi.x + 0.5, roi.y + 0.5, roi.w, roi.h);
    srcCtx.restore();
  }

  function canvasPointFromEvent(e){
    const r = srcCanvas.getBoundingClientRect();
    const scaleX = srcCanvas.width / r.width;
    const scaleY = srcCanvas.height / r.height;
    return {
      x: Math.round((e.clientX - r.left) * scaleX),
      y: Math.round((e.clientY - r.top) * scaleY)
    };
  }

  // Pointer events (мышь+тач)
  srcCanvas.addEventListener('pointerdown', (e) => {
    if (!imageBitmap) return;
    dragging = true;
    srcCanvas.setPointerCapture(e.pointerId);
    const p = canvasPointFromEvent(e);
    dragStart = p;
    roi = { x: p.x, y: p.y, w: 1, h: 1 };
    drawSourceWithRoi();
  });

  srcCanvas.addEventListener('pointermove', (e) => {
    if (!dragging || !imageBitmap) return;
    const p = canvasPointFromEvent(e);
    const x1 = Math.min(dragStart.x, p.x);
    const y1 = Math.min(dragStart.y, p.y);
    const x2 = Math.max(dragStart.x, p.x);
    const y2 = Math.max(dragStart.y, p.y);
    roi = { x: x1, y: y1, w: Math.max(1, x2 - x1), h: Math.max(1, y2 - y1) };
    drawSourceWithRoi();
  });

  srcCanvas.addEventListener('pointerup', async () => {
    if (!dragging) return;
    dragging = false;
    drawSourceWithRoi();
    try { await preprocessToCanvas(); } catch(_) {}
  });

  async function loadImageFromFile(file){
    imageBitmap = await createImageBitmap(file);
    setDefaultRoi();
    drawSourceWithRoi();
    prepCanvas.width = imageBitmap.width;
    prepCanvas.height = imageBitmap.height;
  }

  function parseLangForWorker(langStr){
    const parts = (langStr || '').split('+').map(s => s.trim()).filter(Boolean);
    return parts.length > 1 ? parts : (parts[0] || 'eng');
  }

  function updateCvBadge(){
    cvBadgeEl.textContent = cvReady ? 'OpenCV: готов' : 'OpenCV: нет (fallback)';
  }

  function waitForOpenCvReady(timeoutMs = 15000){
    return new Promise((resolve, reject) => {
      const t0 = Date.now();

      const check = () => {
        if (window.__opencv_load_failed) {
          cvReady = false;
          updateCvBadge();
          return reject(new Error('OpenCV.js не загрузился (ошибка загрузки скрипта).'));
        }

        if (window.cv && typeof cv.Mat === 'function' && typeof cv.getBuildInformation === 'function') {
          cvReady = true;
          updateCvBadge();
          return resolve(true);
        }

        if (window.cv) {
          const prev = cv.onRuntimeInitialized;
          cv.onRuntimeInitialized = () => {
            try { if (typeof prev === 'function') prev(); } catch (_) {}
            cvReady = true;
            updateCvBadge();
            resolve(true);
          };
        }

        if (Date.now() - t0 > timeoutMs) {
          cvReady = false;
          updateCvBadge();
          return reject(new Error('OpenCV.js не инициализировался по таймауту.'));
        }

        setTimeout(check, 80);
      };

      check();
    });
  }

  async function preprocessFallbackToCanvas(){
    if (!imageBitmap) throw new Error('No image');
    clampRoiToCanvas();

    const scale = parseInt(scaleEl.value, 10) || 1;
    prepCanvas.width = Math.max(1, roi.w * scale);
    prepCanvas.height = Math.max(1, roi.h * scale);

    const ctx = prepCanvas.getContext('2d', { willReadFrequently: true });
    ctx.imageSmoothingEnabled = true;

    ctx.clearRect(0, 0, prepCanvas.width, prepCanvas.height);
    ctx.drawImage(
      imageBitmap,
      roi.x, roi.y, roi.w, roi.h,
      0, 0, prepCanvas.width, prepCanvas.height
    );

    if (invertEl.value === '1') {
      const img = ctx.getImageData(0, 0, prepCanvas.width, prepCanvas.height);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        d[i] = 255 - d[i];
        d[i + 1] = 255 - d[i + 1];
        d[i + 2] = 255 - d[i + 2];
      }
      ctx.putImageData(img, 0, 0);
    }

    const blob = await new Promise(resolve => prepCanvas.toBlob(resolve, 'image/png'));
    return blob;
  }

  async function preprocessToCanvas(){
    if (!imageBitmap) throw new Error('No image');

    if (!cvReady || !window.cv || typeof cv.Mat !== 'function') {
      return await preprocessFallbackToCanvas();
    }

    clampRoiToCanvas();

    const roiCanvas = document.createElement('canvas');
    roiCanvas.width = roi.w;
    roiCanvas.height = roi.h;
    const roiCtx = roiCanvas.getContext('2d', { willReadFrequently: true });
    roiCtx.drawImage(imageBitmap, roi.x, roi.y, roi.w, roi.h, 0, 0, roi.w, roi.h);

    const src = cv.imread(roiCanvas); // RGBA
    const gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

    const scale = parseInt(scaleEl.value, 10) || 1;
    let resized = gray;
    if (scale > 1) {
      resized = new cv.Mat();
      const dsize = new cv.Size(gray.cols * scale, gray.rows * scale);
      cv.resize(gray, resized, dsize, 0, 0, cv.INTER_CUBIC);
      gray.delete();
    }

    const threshMode = threshEl.value;
    let out = resized;

    if (threshMode === 'otsu') {
      const bin = new cv.Mat();
      const invert = invertEl.value === '1';
      const t = invert
        ? (cv.THRESH_BINARY_INV | cv.THRESH_OTSU)
        : (cv.THRESH_BINARY | cv.THRESH_OTSU);
      cv.threshold(resized, bin, 0, 255, t);
      if (out !== resized) out.delete();
      out = bin;
    } else if (threshMode === 'adaptive') {
      const bin = new cv.Mat();
      const invert = invertEl.value === '1';
      const adaptiveType = cv.ADAPTIVE_THRESH_GAUSSIAN_C;
      const threshType = invert ? cv.THRESH_BINARY_INV : cv.THRESH_BINARY;
      cv.adaptiveThreshold(resized, bin, 255, adaptiveType, threshType, 31, 7);
      if (out !== resized) out.delete();
      out = bin;
    } else {
      if (invertEl.value === '1') {
        const inv = new cv.Mat();
        cv.bitwise_not(resized, inv);
        if (out !== resized) out.delete();
        out = inv;
      }
    }

    prepCanvas.width = out.cols;
    prepCanvas.height = out.rows;
    cv.imshow(prepCanvas, out);

    src.delete();
    if (resized !== out) resized.delete();
    out.delete();

    const blob = await new Promise(resolve => prepCanvas.toBlob(resolve, 'image/png'));
    return blob;
  }

  async function ensureWorker(langKey, workerLang){
    if (ocrWorker && workerLangKey === langKey) return ocrWorker;

    if (ocrWorker) {
      try { await ocrWorker.terminate(); } catch(_) {}
      ocrWorker = null;
      workerLangKey = null;
    }

    setStatus('Загрузка OCR-моделей…');
    ocrWorker = await Tesseract.createWorker(workerLang, 1, {
      workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js',
      langPath: 'https://tessdata.projectnaptha.com/4.0.0',
      corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@v5.0.0',
      // workerBlobURL: false, // включи, если будут ошибки про Blob worker
      errorHandler: (err) => {
        try { setStatus('OCR worker error: ' + (err?.message || err)); } catch (_) {}
        console.error(err);
      },
      logger: (m) => {
        if (m && typeof m.progress === 'number' && m.status) {
          setStatus(`OCR: ${m.status} ${(m.progress * 100).toFixed(0)}%`);
        }
      }
    });

    workerLangKey = langKey;
    return ocrWorker;
  }

  async function recognize(prepBlob){
    const mode = modeEl.value;
    const psm = String(psmEl.value);

    let workerLang;
    let langKey;

    if (mode === 'text') {
      const langStr = langEl.value; // rus / eng / rus+eng
      workerLang = parseLangForWorker(langStr);
      langKey = langStr;
    } else {
      workerLang = 'eng';
      langKey = 'eng(digits)';
    }

    const worker = await ensureWorker(langKey, workerLang);

    const params = { tessedit_pageseg_mode: psm };
    if (mode === 'digits') {
      params.tessedit_char_whitelist = '0123456789.,-';
    }

    await worker.setParameters(params);
    const ret = await worker.recognize(prepBlob);
    const raw = ret?.data?.text ?? '';
    return raw;
  }

  function makeDocxAndDownload(mode, lang, psm, text, digitsOnly){
    const { Document, Paragraph, Packer } = docx;

    const meta = [];
    meta.push('OCR результат');
    meta.push(`Режим: ${mode}`);
    if (mode === 'text') meta.push(`Язык: ${lang}`);
    meta.push(`PSM: ${psm}`);
    meta.push(`Scale: x${scaleEl.value}`);
    meta.push(`Invert: ${invertEl.value === '1' ? 'yes' : 'no'}`);
    meta.push(`Threshold: ${threshEl.value}`);

    const paras = [];
    for (const s of meta) paras.push(new Paragraph({ text: s }));
    paras.push(new Paragraph({ text: '' }));

    paras.push(new Paragraph({ text: '--- OCR ---' }));
    const lines = (text || '').replace(/\r/g, '').split('\n');
    for (const line of lines) paras.push(new Paragraph({ text: line }));

    paras.push(new Paragraph({ text: '' }));
    paras.push(new Paragraph({ text: '--- Цифры+знаки (фильтр) ---' }));
    paras.push(new Paragraph({ text: digitsOnly || '' }));

    const doc = new Document({ sections: [{ children: paras }] });
    Packer.toBlob(doc).then((blob) => saveAs(blob, 'ocr.docx'));
  }

  // modal logic
  function openModal(){
    serverModal.classList.add('open');
    serverModal.setAttribute('aria-hidden', 'false');
  }
  function closeModal(){
    serverModal.classList.remove('open');
    serverModal.setAttribute('aria-hidden', 'true');
  }

  openServerBtn.addEventListener('click', openModal);
  closeServerModal.addEventListener('click', closeModal);
  serverModal.querySelector('.modal__backdrop').addEventListener('click', closeModal);
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

  serverModal.addEventListener('click', async (e) => {
    const btn = e.target.closest('[data-copy]');
    if (!btn) return;
    const sel = btn.getAttribute('data-copy');
    const pre = serverModal.querySelector(sel);
    const text = (pre?.textContent || '').trim();
    if (!text) return;

    try {
      await navigator.clipboard.writeText(text);
      setStatus('Команда скопирована. Вставь её в терминал в папке с ocr.html.');
    } catch (_) {
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand('copy');
      ta.remove();
      setStatus('Команда скопирована (fallback).');
    }
  });

  fileEl.addEventListener('change', async () => {
    const file = fileEl.files?.[0];
    if (!file) return;

    outEl.value = '';
    digitsEl.value = '';
    dlBtn.disabled = true;
    runBtn.disabled = true;

    setStatus('Загрузка изображения…');
    await loadImageFromFile(file);

    try {
      await preprocessToCanvas();
      setStatus('Готово. Выдели ROI (если нужно) и нажми «Распознать».');
    } catch (e) {
      setStatus(e?.message || 'Ошибка предобработки.');
    }

    runBtn.disabled = false;
  });

  runBtn.addEventListener('click', async () => {
    if (!imageBitmap) return;
    if (workerBusy) return;

    workerBusy = true;
    runBtn.disabled = true;
    dlBtn.disabled = true;

    outEl.value = '';
    digitsEl.value = '';

    try {
      const prepBlob = await preprocessToCanvas();
      setStatus('OCR…');
      const text = await recognize(prepBlob);

      const cleanedText = (text || '').trim();
      outEl.value = cleanedText;

      const digitsOnly = (text || '').replace(/[^0-9.,-]+/g, '');
      digitsEl.value = digitsOnly;

      if (cleanedText.length) {
        dlBtn.disabled = false;
        setStatus('Готово. Можно скачать DOCX.');
      } else {
        setStatus('Ничего не распознано. Попробуй другой ROI/PSM/порог.');
      }
    } catch (e) {
      setStatus(e?.message || 'Ошибка OCR.');
    } finally {
      workerBusy = false;
      runBtn.disabled = false;
    }
  });

  dlBtn.addEventListener('click', () => {
    const mode = modeEl.value;
    const lang = langEl.value;
    const psm = psmEl.value;
    makeDocxAndDownload(mode, lang, psm, outEl.value, digitsEl.value);
  });

  // init
  (async () => {
    refreshUiByMode();
    updateCvBadge();

    setStatus('Загрузка OpenCV.js…');
    try {
      await waitForOpenCvReady(15000);
      setStatus('OpenCV.js готов. Выбери файл для начала.');
    } catch (e) {
      setStatus((e?.message || 'OpenCV.js недоступен') + ' OCR будет работать без OpenCV-предобработки.');
      if (location.protocol === 'file:') {
        setStatus('Открыто как file://. Рекомендуется запустить локальный сервер (кнопка «Открыть локальный сервер»).');
        openModal();
      }
    }

    runBtn.disabled = true;
  })();

  window.addEventListener('beforeunload', async () => {
    if (ocrWorker) {
      try { await ocrWorker.terminate(); } catch(_) {}
    }
  });
</script>
</body>
</html>
